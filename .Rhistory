geom.ind = "point", # Muestra individuos como puntos
pointshape = 21,
pointsize = 2,
fill.ind = onlyevents$City, # <--- Colorea los puntos por Ciudad
palette = "Set1", # Paleta de colores
addEllipses = TRUE, # <--- Dibuja elipses alrededor de las ciudades
legend.title = list(fill = "Location"))
print(biplot)
### PCA con PCA del paquete FactoMineR
# Filtrar solo el período "Event"
onlyevents <- Events2 %>%
filter(Event == "Event")
library(readxl)
Events2 <- read_excel("Events2.xlsx", sheet = "Pop consump = days NoKet THCCOO")
View(Events2)
### PCA con PCA del paquete FactoMineR
# Filtrar solo el período "Event"
onlyevents <- Events2 %>%
filter(Event == "Event")
# Guardar las etiquetas de las ciudades para los gráficos y crear una etiqueta única para cada punto combinando City and Day
# Como LF4 tiene varios Mo, Tu, etc, necesario crear una etiqueta única (es lo que se hace primero)
onlyevents_for_PCA <- onlyevents %>%
# Agrupamos por las columnas que podrían estar duplicadas
group_by(City, Day) %>%
# Creamos un ID de muestra (1, 2, 3...) para cada duplicado
mutate(sample_num = row_number()) %>%
ungroup() %>%
mutate(label = paste(City, Day, sample_num, sep = "_")) %>%
select(label, Amphetamine, Methamphetamine, MDMA, Cocaine, THCCOOH, NIC, EtOH) %>%
column_to_rownames("label")
# PCA con PCA solamente (produce el drug correlation circle)
PCA <- PCA(onlyevents_for_PCA, scale.unit = TRUE)
# PCA con PCA
# scale.unit = TRUE es VITAL. Esto hace el escalado/estandarización.
# graph = FALSE previene que R abra ventanas de gráficos por defecto.
pca_result <- PCA(onlyevents_for_PCA, scale.unit = TRUE, graph = FALSE)
cat("--- Resumen del PCA (Cuánta varianza explica cada componente) ---\n")
print(summary(pca_result))
# --- Gráfico 1: Scree Plot (Varianza explicada) ---
# Muestra cuánta "información" (varianza) captura cada Componente Principal (Dim).
# Nos fijamos en las primeras 2 o 3 barras.
scree_plot <- fviz_eig(pca_result, addlabels = TRUE,
title = "Events - Scree Plot")
print(scree_plot)
# --- Gráfico 2: Círculo de Correlación (Variables) ---
# Muestra cómo se relacionan las DROGAS.
# - Flechas juntas = correlación positiva (se consumen juntas).
# - Flechas opuestas = correlación negativa.
# - Flechas largas = bien representadas en el PCA.
var_plot <- fviz_pca_var(pca_result, col.var = "contrib",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE, # Evita que los textos se superpongan
title = "Events - Drug correlation circle")
print(var_plot)
# --- Gráfico 3: Biplot (Individuos + Variables) ---
# ¡Este es el gráfico principal! Combina todo.
# Muestra qué DÍAS/CIUDADES (puntos) están "impulsados" por qué DROGAS (flechas).
biplot <- fviz_pca_biplot(pca_result,
repel = TRUE, # Evita solapamiento
title = "Events - Biplot (Days/Locations and Drugs)",
# Opciones de estética
geom.ind = "point", # Muestra individuos como puntos
pointshape = 21,
pointsize = 2,
fill.ind = onlyevents$City, # <--- Colorea los puntos por Ciudad
palette = "Set1", # Paleta de colores
addEllipses = TRUE, # <--- Dibuja elipses alrededor de las ciudades
legend.title = list(fill = "Location"))
print(biplot)
View(onlyevents)
library(readxl)
ForGem <- read_excel("ForGem.xlsx", sheet = "Normal")
View(ForGem)
# Seleccionar solo las columnas de las drogas
onlynormal_numeric <- ForGem %>%
select(Amphetamine, Methamphetamine, MDMA, Cocaine, THCCOOH, NIC, EtOH)
# PCA
pca_result <- prcomp(onlynormal_numeric, center = TRUE, scale. = TRUE)
print(summary(pca_result))
# 5.1. Gráfico de Sedimentación (Scree Plot)
# Muestra la varianza explicada por cada componente.
# Ayuda a decidir cuántos componentes son "importantes".
scree_plot <- fviz_eig(pca_result, addlabels = TRUE, title = "Non-Event periods - Scree Plot")
print(scree_plot)
# --- Gráfico 3: Biplot (Individuos + Variables) ---
# ¡Este es el gráfico principal! Combina todo.
# Muestra qué DÍAS/CIUDADES (puntos) están "impulsados" por qué DROGAS (flechas).
biplot <- fviz_pca_biplot(pca_result,
repel = TRUE, # Evita solapamiento
title = "Non-event periods - Biplot (Days/Locations and Drugs)",
# Opciones de estética
geom.ind = "point", # Muestra individuos como puntos
pointshape = 21,
pointsize = 2,
fill.ind = onlynormal$City, # <--- Colorea los puntos por Ciudad
palette = "Set1", # Paleta de colores
addEllipses = FALSE, # <--- Dibuja elipses alrededor de las ciudades
legend.title = list(fill = "Location"))
biplot <- fviz_pca_biplot(pca_result,
repel = TRUE, # Evita solapamiento
title = "Non-event periods - Biplot (Days/Locations and Drugs)",
# Opciones de estética
geom.ind = "point", # Muestra individuos como puntos
pointshape = 21,
pointsize = 2,
fill.ind = ForGem$City, # <--- Colorea los puntos por Ciudad
palette = "Set1", # Paleta de colores
addEllipses = FALSE, # <--- Dibuja elipses alrededor de las ciudades
legend.title = list(fill = "Location"))
print(biplot)
library(readxl)
ForGem <- read_excel("ForGem.xlsx", sheet = "Normal")
View(ForGem)
onlynormal_numeric <- ForGem %>%
select(Amphetamine, Methamphetamine, MDMA, Cocaine, THCCOOH, NIC, EtOH)
View(onlynormal_numeric)
pca_result <- prcomp(onlynormal_numeric, center = TRUE, scale. = TRUE)
print(summary(pca_result))
biplot <- fviz_pca_biplot(pca_result,
repel = TRUE, # Evita que las etiquetas se superpongan
geom.ind = "point", # Muestra las muestras como puntos
col.ind = onlynormal$City, # Colorea los puntos por Ciudad
addEllipses = TRUE, # Dibuja elipses de confianza por grupo
legend.title = "Location",
title = "Non-event periods - Biplot (Days/Locations and Drugs)"
)
biplot <- fviz_pca_biplot(pca_result,
repel = TRUE, # Evita que las etiquetas se superpongan
geom.ind = "point", # Muestra las muestras como puntos
col.ind = ForGem$City, # Colorea los puntos por Ciudad
addEllipses = TRUE, # Dibuja elipses de confianza por grupo
legend.title = "Location",
title = "Non-event periods - Biplot (Days/Locations and Drugs)"
)
print(biplot)
biplot <- fviz_pca_biplot(pca_result,
repel = TRUE, # Evita solapamiento
title = "Non-event periods - Biplot (Days/Locations and Drugs)",
# Opciones de estética
geom.ind = "point", # Muestra individuos como puntos
pointshape = 21,
pointsize = 2,
fill.ind = ForGem$City, # <--- Colorea los puntos por Ciudad
palette = "Set1", # Paleta de colores
addEllipses = FALSE, # <--- Dibuja elipses alrededor de las ciudades
legend.title = list(fill = "Location"))
print(biplot)
table(ForGem$City)
library(readxl)
ForGem <- read_excel("ForGem.xlsx", sheet = "Normal")
View(ForGem)
table(ForGem$City)
setwd("D:/OneDrive - Universidad de Salamanca/2024-2025_Investigacion/PAPER_EVENTOS/ForR")
library(readxl)
library(tidyverse)
library(viridis)
library(factoextra) #para prcomp. Mejor no, me ha funcionado mejor FactoMineR
library(FactoMineR) #para PCA
library(readxl)
Normal <- read_excel("Normal.xlsx")
View(Normal)
library(readxl)
Normal <- read_excel("Normal.xlsx")
View(Normal)
# Seleccionar solo las columnas de las drogas
onlynormal_numeric <- ForGem %>%
select(Amphetamine, Methamphetamine, MDMA, Cocaine, THCCOOH, NIC, EtOH)
onlynormal_numeric <- Normal %>%
select(Amphetamine, Methamphetamine, MDMA, Cocaine, THCCOOH, NIC, EtOH)
View(onlynormal_numeric)
# PCA
pca_result <- prcomp(onlynormal_numeric, center = TRUE, scale. = TRUE)
print(summary(pca_result))
# Biplot rotado ESTE MEJOR NO (segunda dim en eje x, para coincidir con las de Event)
biplot <- fviz_pca_biplot(pca_result,
axes = c(2 ,1),
repel = TRUE, # Evita que las etiquetas se superpongan
geom.ind = "point", # Muestra las muestras como puntos
col.ind = Normal$City, # Colorea los puntos por Ciudad
addEllipses = TRUE, # Dibuja elipses de confianza por grupo
legend.title = "Location",
title = "Non-event periods - Biplot (Days/Locations and Drugs)"
)
print(biplot)
biplot <- fviz_pca_biplot(pca_result,
repel = TRUE,
title = "Non-event periods - Biplot (Days/Locations and Drugs)",
geom.ind = "point",
pointshape = 21,
pointsize = 2,
fill.ind = Normal$City, # <--- Colorea usando 'normal_data'
palette = "Set1",
addEllipses = FALSE,
legend.title = list(fill = "Location"))
print(biplot)
table(Normal$City)
############################################################################### #
# Aim ----
#| load, clean and save data
# NOTES:
#| git cheat: git status, git add -A, git commit -m "", git push, git pull, git restore
#| list of things to do...
############################################################################### #
# Load packages ----
# select packages
pkgs <- c("dplyr", "tidyr", "zoo", "writexl", "flextable", "ggplot2", "quarto")
# install packages
install.packages(setdiff(pkgs, rownames(installed.packages())))
invisible(lapply(pkgs, FUN = library, character.only = TRUE))
# load data ----
# Belgian data are available here https://www.geo.be/catalog/details/9eec5acf-a2df-11ed-9952-186571a04de2?l=en
#| Metadata
#| siteName is the name of the treatment plant
#| collDTStart is the date of sampling
#| labName is the name of the lab analysing the sample
#| labProtocolID is the protocol used to analyse the dample
#| flowRate is the flow rate measured at the inlet of the treatment plant during sampling
#| popServ is the population covered by the treatment plant
#| measure is the target measured
#| value is the result
# sars-cov-2 data
df_sc <- read.csv("https://data.geo.be/ws/sciensano/wfs?SERVICE=WFS&REQUEST=GetFeature&VERSION=2.0.0&TYPENAMES=sciensano:wastewatertreatmentplantscovid&outputFormat=csv")
# pmmv data
df_pmmv <- read.csv("https://data.geo.be/ws/sciensano/wfs?SERVICE=WFS&REQUEST=GetFeature&VERSION=2.0.0&TYPENAMES=sciensano:wastewatertreatmentplantspmmv&outputFormat=csv")
# join both
df <- df_sc %>%
rbind(df_pmmv)
# clean data
df <- df %>%
select(siteName, collDTStart, labName, labProtocolID, flowRate, popServ, measure, value, quality) %>%
rename(date = collDTStart) %>%
mutate(date = as.Date(date))
# set and subset dates
date_reporting <- as.Date("2025-09-01", format = "%Y-%m-%d")
date_graph_start <- as.Date("2024-09-01", format = "%Y-%m-%d")
date_graph_end <- as.Date("2025-12-01", format = "%Y-%m-%d")
# subset sars and pmmv data based on labProtocolID used betwen date_start and date_end
# display existing labProtocolID
# unique(df$labProtocolID)
df <- df %>%
filter(labProtocolID %in%
c("SC_COV_4.1",
"UA_COV_4.0",
"SC_PMMV_2.1",
"UA_PMMV_2.0"))
# rename measures
# diplay existing measure
# unique(df$measure)
df[df$measure == "SARS-CoV-2 E gene", ]$measure <- "SARS"
df[df$measure == "SARS-CoV-2 nucleocapsid gene, allele 2", ]$measure <- "SARS"
df[df$measure == "Pepper mild mottle virus capsid protein gene region", ]$measure <- "PMMV"
# translate siteName to english
df[df$siteName == "Bruxelles-Sud", ]$siteName <- "Brussels-South"
df[df$siteName == "Bruxelles-Nord", ]$siteName <- "Brussels-North"
# apply LOQ provided by the lab
df[df$measure == "PMMV" & df$value < 250, ]$value <- NA
df[df$measure == "SARS" & df$value < 8, ]$value <- NA
# remove outliers
df[df$quality == "Quality concerns", ]$value <- NA
# normalization ----
# compute mean of replicated analysis of each measure
df <- df %>%
select(date, siteName, labName, flowRate, popServ, measure, value) %>%
group_by(date, siteName, labName, flowRate, popServ, measure) %>%
summarise(value = mean(value, na.rm = TRUE)) %>% ungroup()
# pivot
df <- df %>%
pivot_wider(names_from = measure, values_from = value)
# compute viral load (value_load), viral ratio (value_ratio)
df <- df %>%
pivot_longer(cols = SARS, names_to = "measure", values_to = "value") %>%
mutate(value_load = value*flowRate*24*1000000/popServ*100000,
value_pmmv = value/PMMV)
# save
df_site_raw <- df
# smoothening ----
# compute the linear extrapolation data
df <- df_site_raw %>%
group_by(siteName) %>%
complete(date = seq(min(date), max(date), "day")) %>%
mutate(value_avg14d_past = na.approx(value, maxgap = 14, na.rm = FALSE),
value_load_avg14d_past = na.approx(value_load, maxgap = 14, na.rm = FALSE),
value_pmmv_avg14d_past = na.approx(value_pmmv, maxgap = 14, na.rm = FALSE))
# compute moving average on past 14 days
df <- df %>%
group_by(siteName) %>%
mutate(across(value_avg14d_past:value_pmmv_avg14d_past,
~ rollmean(.x, k = 14, fill = NA, na.rm = TRUE, align = "right")))
# save
df_site <- df
# national level ----
## aggregation ----
# compute weighted mean with factor being the population served by each site
df <- df_site_raw %>%
select(date, popServ, value, value_load, value_pmmv) %>%
mutate(siteName = "Belgium") %>%
group_by(siteName, date) %>%
summarise(across(value:value_pmmv, ~ weighted.mean(.x, popServ, na.rm=TRUE))) %>% ungroup()
## smoothening ----
# linear extrapolation data
df <- df %>%
group_by(siteName) %>%
complete(date = seq(min(date), max(date), "day")) %>%
mutate(value_avg14d_past = na.approx(value, maxgap = 14, na.rm = FALSE),
value_load_avg14d_past = na.approx(value_load, maxgap = 14, na.rm = FALSE),
value_pmmv_avg14d_past = na.approx(value_pmmv, maxgap = 14, na.rm = FALSE))
# moving average on past 14 days
df <- df %>%
group_by(siteName) %>%
mutate(across(value_avg14d_past:value_pmmv_avg14d_past,
~ rollmean(.x, k = 14, fill = NA, na.rm = TRUE, align = "right")))
# save
df_nation <- df
# export data ----
# create folder if not existing
dir.create("./data", showWarnings = F)
# export as csv
write.table(df_site_raw, file = "./data/Belgium_export-site_raw.csv", sep = ";", dec = ".",
col.names = TRUE, row.names = FALSE)
write.table(df_nation, file = "./data/Belgium_export-site.csv", sep = ";", dec = ".",
col.names = TRUE, row.names = FALSE)
write.table(df_nation, file = "./data/Belgium_export-nation.csv", sep = ";", dec = ".",
col.names = TRUE, row.names = FALSE)
# export as xls
write_xlsx(
list(site_raw = df_site_raw, site = df_site, nation = df_nation),
path = "./data/Belgium_export.xlsx"
)
# export as rds
saveRDS(list(df_site_raw, df_site, df_nation),
file = "./data/Belgium_export.rds")
# display msg
cat("- Success : data prep \n")
View(df_site_raw)
View(df_site_raw)
View(df_site)
View(df_site_raw)
View(df_site)
View(df_site_raw)
View(df_sc)
View(df_site_raw)
View(df_site)
View(df_site)
View(df_site_raw)
library(readr)
Belgium_export_nation <- read_csv("Belgium_export-nation.csv")
View(Belgium_export_nation)
View(Belgium_export_nation)
# load data ----
# Belgian data are available here https://www.geo.be/catalog/details/9eec5acf-a2df-11ed-9952-186571a04de2?l=en
#| Metadata
#| siteName is the name of the treatment plant
#| collDTStart is the date of sampling
#| labName is the name of the lab analysing the sample
#| labProtocolID is the protocol used to analyse the dample
#| flowRate is the flow rate measured at the inlet of the treatment plant during sampling
#| popServ is the population covered by the treatment plant
#| measure is the target measured
#| value is the result
# sars-cov-2 data
df_sc <- read.csv("https://data.geo.be/ws/sciensano/wfs?SERVICE=WFS&REQUEST=GetFeature&VERSION=2.0.0&TYPENAMES=sciensano:wastewatertreatmentplantscovid&outputFormat=csv")
# pmmv data
df_pmmv <- read.csv("https://data.geo.be/ws/sciensano/wfs?SERVICE=WFS&REQUEST=GetFeature&VERSION=2.0.0&TYPENAMES=sciensano:wastewatertreatmentplantspmmv&outputFormat=csv")
# join both
df <- df_sc %>%
rbind(df_pmmv)
# clean data
df <- df %>%
select(siteName, collDTStart, labName, labProtocolID, flowRate, popServ, measure, value)
# format date
df$date <- as.Date(df$date)
############################################################################### #
# Aim ----
#| load, clean and save data
# NOTES:
#| git cheat: git status, git add -A, git commit -m "", git push, git pull, git restore
#| list of things to do...
############################################################################### #
# Load packages ----
# select packages
pkgs <- c("dplyr", "tidyr", "zoo", "writexl", "flextable", "ggplot2", "quarto")
# install packages
install.packages(setdiff(pkgs, rownames(installed.packages())))
invisible(lapply(pkgs, FUN = library, character.only = TRUE))
# load data ----
# Belgian data are available here https://www.geo.be/catalog/details/9eec5acf-a2df-11ed-9952-186571a04de2?l=en
#| Metadata
#| siteName is the name of the treatment plant
#| collDTStart is the date of sampling
#| labName is the name of the lab analysing the sample
#| labProtocolID is the protocol used to analyse the dample
#| flowRate is the flow rate measured at the inlet of the treatment plant during sampling
#| popServ is the population covered by the treatment plant
#| measure is the target measured
#| value is the result
# sars-cov-2 data
df_sc <- read.csv("https://data.geo.be/ws/sciensano/wfs?SERVICE=WFS&REQUEST=GetFeature&VERSION=2.0.0&TYPENAMES=sciensano:wastewatertreatmentplantscovid&outputFormat=csv")
# pmmv data
df_pmmv <- read.csv("https://data.geo.be/ws/sciensano/wfs?SERVICE=WFS&REQUEST=GetFeature&VERSION=2.0.0&TYPENAMES=sciensano:wastewatertreatmentplantspmmv&outputFormat=csv")
# join both
df <- df_sc %>%
rbind(df_pmmv)
# clean data
df <- df %>%
select(siteName, collDTStart, labName, labProtocolID, flowRate, popServ, measure, value, quality) %>%
rename(date = collDTStart) %>%
mutate(date = as.Date(date))
# set and subset dates
date_reporting <- as.Date("2025-09-01", format = "%Y-%m-%d")
date_graph_start <- as.Date("2024-09-01", format = "%Y-%m-%d")
date_graph_end <- as.Date("2025-12-01", format = "%Y-%m-%d")
# subset sars and pmmv data based on labProtocolID used betwen date_start and date_end
# display existing labProtocolID
# unique(df$labProtocolID)
df <- df %>%
filter(labProtocolID %in%
c("SC_COV_4.1",
"UA_COV_4.0",
"SC_PMMV_2.1",
"UA_PMMV_2.0"))
# rename measures
# diplay existing measure
# unique(df$measure)
df[df$measure == "SARS-CoV-2 E gene", ]$measure <- "SARS"
df[df$measure == "SARS-CoV-2 nucleocapsid gene, allele 2", ]$measure <- "SARS"
df[df$measure == "Pepper mild mottle virus capsid protein gene region", ]$measure <- "PMMV"
# translate siteName to english
df[df$siteName == "Bruxelles-Sud", ]$siteName <- "Brussels-South"
df[df$siteName == "Bruxelles-Nord", ]$siteName <- "Brussels-North"
# apply LOQ provided by the lab
df[df$measure == "PMMV" & df$value < 250, ]$value <- NA
df[df$measure == "SARS" & df$value < 8, ]$value <- NA
# remove outliers
df[df$quality == "Quality concerns", ]$value <- NA
# normalization ----
# compute mean of replicated analysis of each measure
df <- df %>%
select(date, siteName, labName, flowRate, popServ, measure, value) %>%
group_by(date, siteName, labName, flowRate, popServ, measure) %>%
summarise(value = mean(value, na.rm = TRUE)) %>% ungroup()
# pivot
df <- df %>%
pivot_wider(names_from = measure, values_from = value)
# compute viral load (value_load), viral ratio (value_ratio)
df <- df %>%
pivot_longer(cols = SARS, names_to = "measure", values_to = "value") %>%
mutate(value_load = value*flowRate*24*1000000/popServ*100000,
value_pmmv = value/PMMV)
# save
df_site_raw <- df
# smoothening ----
# compute the linear extrapolation data
df <- df_site_raw %>%
group_by(siteName) %>%
complete(date = seq(min(date), max(date), "day")) %>%
mutate(value_avg14d_past = na.approx(value, maxgap = 14, na.rm = FALSE),
value_load_avg14d_past = na.approx(value_load, maxgap = 14, na.rm = FALSE),
value_pmmv_avg14d_past = na.approx(value_pmmv, maxgap = 14, na.rm = FALSE))
# compute moving average on past 14 days
df <- df %>%
group_by(siteName) %>%
mutate(across(value_avg14d_past:value_pmmv_avg14d_past,
~ rollmean(.x, k = 14, fill = NA, na.rm = TRUE, align = "right")))
# save
df_site <- df
# national level ----
## aggregation ----
# compute weighted mean with factor being the population served by each site
df <- df_site_raw %>%
select(date, popServ, value, value_load, value_pmmv) %>%
mutate(siteName = "Belgium") %>%
group_by(siteName, date) %>%
summarise(across(value:value_pmmv, ~ weighted.mean(.x, popServ, na.rm=TRUE))) %>% ungroup()
## smoothening ----
# linear extrapolation data
df <- df %>%
group_by(siteName) %>%
complete(date = seq(min(date), max(date), "day")) %>%
mutate(value_avg14d_past = na.approx(value, maxgap = 14, na.rm = FALSE),
value_load_avg14d_past = na.approx(value_load, maxgap = 14, na.rm = FALSE),
value_pmmv_avg14d_past = na.approx(value_pmmv, maxgap = 14, na.rm = FALSE))
# moving average on past 14 days
df <- df %>%
group_by(siteName) %>%
mutate(across(value_avg14d_past:value_pmmv_avg14d_past,
~ rollmean(.x, k = 14, fill = NA, na.rm = TRUE, align = "right")))
# save
df_nation <- df
# export data ----
# create folder if not existing
dir.create("./data", showWarnings = F)
# export as csv
write.table(df_site_raw, file = "./data/Belgium_export-site_raw.csv", sep = ";", dec = ".",
col.names = TRUE, row.names = FALSE)
write.table(df_nation, file = "./data/Belgium_export-site.csv", sep = ";", dec = ".",
col.names = TRUE, row.names = FALSE)
write.table(df_nation, file = "./data/Belgium_export-nation.csv", sep = ";", dec = ".",
col.names = TRUE, row.names = FALSE)
# export as xls
write_xlsx(
list(site_raw = df_site_raw, site = df_site, nation = df_nation),
path = "./data/Belgium_export.xlsx"
)
# export as rds
saveRDS(list(df_site_raw, df_site, df_nation),
file = "./data/Belgium_export.rds")
# display msg
cat("- Success : data prep \n")
source("~/training-eu_wish-team_9/01_data_prep-solution.R", echo = TRUE)
library(readr)
Belgium_export_nation <- read_csv("Belgium_export-nation.csv")
View(Belgium_export_nation)
